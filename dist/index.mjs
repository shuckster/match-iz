/*
 * match-iz
 * v4.0.4
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var P=Object.defineProperty;var b=Object.getOwnPropertySymbols;var q=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var L=(t,e,n)=>e in t?P(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,C=(t,e)=>{for(var n in e||(e={}))q.call(e,n)&&L(t,n,e[n]);if(b)for(var n of b(e))z.call(e,n)&&L(t,n,e[n]);return t};var H=(t,e)=>{var n={};for(var s in t)q.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&b)for(var s of b(t))e.indexOf(s)<0&&z.call(t,s)&&(n[s]=t[s]);return n};var Y=(t,e)=>{for(var n in e)P(t,n,{get:e[n],enumerable:!0})};var S={};Y(S,{instanceOf:()=>a,isArguments:()=>$,isArray:()=>_,isDate:()=>x,isFormData:()=>it,isFunction:()=>j,isIterable:()=>rt,isMap:()=>st,isNumber:()=>tt,isObject:()=>B,isPojo:()=>ot,isRegExp:()=>et,isSet:()=>nt,isString:()=>k});var V=Object.prototype,Z=V.toString,F=t=>e=>typeof e===t,a=t=>e=>e instanceof t,{isArray:_}=Array,$=t=>Z.call(t)==="[object Arguments]",x=t=>a(Date)(t)&&!isNaN(t),j=F("function"),k=F("string"),tt=t=>t===t&&F("number")(t),B=t=>t!==null&&F("object")(t),et=a(RegExp),nt=a(Set),st=a(Map),ot=t=>t===null||!B(t)||$(t)?!1:Object.getPrototypeOf(t)===V,rt=t=>t!=null&&[t[Symbol.iterator],t.next].every(j),it=t=>typeof FormData!="undefined"&&a(FormData)(t);var{isArguments:ct,isArray:g,isDate:Dt,isFunction:h,isNumber:ut}=S,{isPojo:d,isRegExp:G,isString:y,instanceOf:Kt}=S,{isMap:lt,isSet:ft,isIterable:mt,isFormData:gt}=S,{keys:p,entries:pt,assign:N}=Object,w=2e4,ht=!0,Wt=()=>w,Rt=t=>{let e=w;return w=t,()=>w=e};function dt(t,e){for(let n=t.length-1;n>=0;n--)if(e(t[n]))return t[n]}function J(t,e){if(ht&&!M(e)){let n=`Exhausted all patterns without finding a match for input: ${JSON.stringify(t)}. Handle it, or use otherwise() for the fall-through case.`;throw new Error(n)}}function At(t){return(...e)=>at(...e)(t)}var at=(...t)=>e=>{let[n,s]=ct(e)?[{},Array.from(e)]:lt(e)||gt(e)?[{isMap:!0},e.entries()]:ft(e)?[{isSet:!0},e.values()]:[{},e];if(!mt(s)){let i=s,{found:m,result:f}=U(...t)(i);if(m)return f;let O=dt(t,M);return J(i,O),f}let r=s,[c,u]=t.reduce(([i,m],f)=>M(f)?[f,m]:[i,[...m,f]],[()=>({value:()=>{}}),[]]),o=[];do{let{value:i,done:m}=r.next();if(m)return J(r,c),c().value();o.push(i);let{found:f,result:O}=U(...u)(n.isSet?i:n.isMap?{key:i[0],value:i[1]}:[...o]);if(f)return O}while(o.length<w||n.isSet||n.isMap);throw new Error(`Hit iterationLimit: ${w}. Use setIterationLimit(Infinity) to disable.`)},U=(...t)=>{let e;return n=>({found:!!t.find(r=>{let c=r(n),{matched:u,value:o}=c||{};return[u,o].every(h)?u(n)&&(e=o(n),!0):c&&(e=c)}),result:e})},D="@@match-iz/rest",wt=t=>h(t==null?void 0:t[D]),Ot=t=>t[D],Q=Symbol("@@match-iz/otherwise"),M=t=>(t==null?void 0:t[Q])===!0,Lt=t=>{let e=n=>({matched:()=>!0,value:()=>h(t)?t(n):t});return e[Q]=!0,e},I=t=>e=>n=>{let s={haystack:n};return{matched:()=>l(t,n,r=>n=r,s),value:()=>h(e)?y(n)&&G(t)?e(...St(n.match(t),s.rest)):e(n,s.rest):e}},Pt=(...t)=>{if(t.length===1){let[e]=t;return I(e)}if(t.length===2){let[e,n]=t;return I(e)(n)}if(t.length>2){let e=t.slice(-1)[0],n=t.slice(0,-1);return I(Nt(n))(e)}throw new Error("Expected at least 1 argument")},St=t=>{let{groups:e}=t;return e?[e,t]:[t]},l=(t,e,n,s={haystack:e})=>d(t)?p(t).every(r=>(s.consumedKeys=s.consumedKeys||[],s.consumedKeys.push(r),s.key=r,l(t[r],e==null?void 0:e[r],n,s))):g(t)?g(e)&&t.every((r,c)=>{let u=wt(r)?Ot(r):r;return s.key=c,l(u,e==null?void 0:e[c],n,s)}):h(t)?t(e,n,s):y(e)&&G(t)?t.test(e):t===e||[t,e].every(Number.isNaN),qt=(...t)=>(e,n,s)=>t.length===0||(h(t[0])?t[0](e):l(t[0],e,n,s))?(n(e),!0):!1,zt=(...t)=>{let e=t.length===0?()=>!0:t[0],n=()=>e,s=c=>(u,o)=>N(u,{[o]:c.haystack[o]}),r=(c,u)=>N(c,{[u]:e});return{[D]:(c,u,o)=>{if(d(o.haystack)){let i=[],m=p(o.haystack).reduce((A,E)=>((o.consumedKeys||[]).includes(E)?i.push(E):A.push(E),A),[]),f=i.reduce(s(o),{}),O=m.reduce(r,{}),R=l(N({},f,O),o.haystack,u);return R&&(o.rest=m.reduce(s(o),{})),R}if(g(o.haystack)){let i=o.haystack.slice(0,o.key),m=o.haystack.slice(o.key).map(n),f=l(i.concat(m),o.haystack,u);return f&&(o.rest=o.haystack.slice(o.key)),f}return!1}}},vt=(t,e)=>[t,e].every(g)?t.length===e.length:[t,e].every(d)?p(t).length===p(e).length:!0,bt=t=>(e,n,s)=>vt(t,e)&&l(t,e,n,s),Ct=t=>K(t,e=>d(e)?bt(e):e),Ht=t=>(e,n,s)=>!l(t,e,n,s),Ft=(...t)=>(e,n,s)=>t.flat().some(r=>l(r,e,n,s)),Nt=(...t)=>(e,n,s)=>t.flat().every(r=>l(r,e,n,s)),Vt=t=>X((e,n,s)=>e.every(r=>l(t,r,n,s))),$t=t=>X((e,n,s)=>e.some(r=>l(t,r,n,s))),jt=(...t)=>W((e,n,s)=>t.length<=e.length&&l(t,e.slice(0,t.length),n,s)),Bt=(...t)=>W((e,n,s)=>t.length<=e.length&&l(t,e.slice(e.length-t.length),n,s)),yt=t=>t!==t||!t&&t!==0&&t!==!1||g(t)&&!t.length||d(t)&&!p(t).length,Jt=t=>!yt(t),Ut=t=>v(e=>e>t),Gt=t=>v(e=>e<t),Qt=t=>v(e=>e>=t),Tt=t=>v(e=>e<=t),Xt=(t,e)=>v(n=>n>=Math.min(t,e)&&n<=Math.max(t,e)),Yt=t=>T(e=>e.startsWith(t)),Zt=t=>T(e=>e.endsWith(t)),_t=t=>W(e=>e.includes(t)),xt=Ft,kt=t=>e=>e===t,te=(...t)=>e=>d(e)&&(([n,s])=>n.length&&n.every(r=>s.includes(r)))([t.flat(),p(e)]),ee=n=>{var s=n,{getValue:t}=s,e=H(s,["getValue"]);return pt(e).reduce((r,[c,u])=>N(r,{[c]:o=>i=>({matched:()=>u(i),value:()=>h(o)?o(t(i)):o})}),{})},ne=t=>!!t,se=t=>!t,Et=t=>(e,n)=>(e[n]=K(e[n],t),e),It=t=>e=>K(e,t),K=(t,e)=>e(d(t)?p(t).reduce(Et(e),C({},t)):g(t)?t.map(It(e)):t),oe=t=>new Proxy({},{get:()=>t}),T=t=>e=>y(e)&&t(e),v=t=>e=>ut(e)&&t(e),X=t=>(e,n,s)=>g(e)&&t(e,n,s),W=t=>(e,n,s)=>(g(e)||y(e))&&t(e,n,s);export{at as against,Nt as allOf,Ft as anyOf,ee as cata,Ct as deepEq,Jt as defined,yt as empty,Zt as endsWith,bt as eq,Vt as every,se as falsy,jt as firstOf,Wt as getIterationLimit,Ut as gt,Qt as gte,te as hasOwn,Xt as inRange,xt as includedIn,_t as includes,Kt as instanceOf,g as isArray,Dt as isDate,h as isFunction,mt as isIterable,ut as isNumber,d as isPojo,G as isRegExp,kt as isStrictly,y as isString,Bt as lastOf,Gt as lt,Tt as lte,At as match,Ht as not,Lt as otherwise,qt as pluck,zt as rest,Rt as setIterationLimit,$t as some,oe as spread,Yt as startsWith,ne as truthy,Pt as when};
