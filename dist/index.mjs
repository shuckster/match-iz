/*
 * match-iz
 * v4.0.4
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var P=Object.defineProperty;var b=Object.getOwnPropertySymbols;var R=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable;var L=(t,e,n)=>e in t?P(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,z=(t,e)=>{for(var n in e||(e={}))R.call(e,n)&&L(t,n,e[n]);if(b)for(var n of b(e))q.call(e,n)&&L(t,n,e[n]);return t};var C=(t,e)=>{var n={};for(var s in t)R.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&b)for(var s of b(t))e.indexOf(s)<0&&q.call(t,s)&&(n[s]=t[s]);return n};var X=(t,e)=>{for(var n in e)P(t,n,{get:e[n],enumerable:!0})};var S={};X(S,{instanceOf:()=>w,isArguments:()=>V,isArray:()=>Z,isDate:()=>_,isFormData:()=>rt,isFunction:()=>$,isIterable:()=>ot,isMap:()=>nt,isNumber:()=>k,isObject:()=>j,isPojo:()=>st,isRegExp:()=>tt,isSet:()=>et,isString:()=>x});var H=Object.prototype,Y=H.toString,F=t=>e=>typeof e===t,w=t=>e=>e instanceof t,{isArray:Z}=Array,V=t=>Y.call(t)==="[object Arguments]",_=t=>w(Date)(t)&&!isNaN(t),$=F("function"),x=F("string"),k=t=>t===t&&F("number")(t),j=t=>t!==null&&F("object")(t),tt=w(RegExp),et=w(Set),nt=w(Map),st=t=>t===null||!j(t)||V(t)?!1:Object.getPrototypeOf(t)===H,ot=t=>t!=null&&[t[Symbol.iterator],t.next].every($),rt=t=>typeof FormData!="undefined"&&w(FormData)(t);var{isArguments:it,isArray:g,isDate:Dt,isFunction:d,isNumber:ct}=S,{isPojo:h,isRegExp:U,isString:y,instanceOf:Kt}=S,{isMap:ut,isSet:lt,isIterable:ft,isFormData:mt}=S,{keys:p,entries:gt,assign:N}=Object,O=2e4,pt=!0,Mt=()=>O,Wt=t=>{let e=O;return O=t,()=>O=e};function dt(t,e){for(let n=t.length-1;n>=0;n--)if(e(t[n]))return t[n]}function B(t,e){if(pt&&!D(e)){let n=`Exhausted all patterns without finding a match for input: ${JSON.stringify(t)}. Handle it, or use otherwise() for the fall-through case.`;throw new Error(n)}}function At(t){return(...e)=>ht(...e)(t)}var ht=(...t)=>e=>{let[n,s]=it(e)?[{},Array.from(e)]:ut(e)||mt(e)?[{isMap:!0},e.entries()]:lt(e)?[{isSet:!0},e.values()]:[{},e];if(!ft(s)){let c=s,{found:f,result:m}=J(...t)(c);if(f)return m;let a=dt(t,D);return B(c,a),m}let o=s,[i,r]=t.reduce(([c,f],m)=>D(m)?[m,f]:[c,[...f,m]],[()=>({value:()=>{}}),[]]),u=[];do{let{value:c,done:f}=o.next();if(f)return B(o,i),i().value();u.push(c);let{found:m,result:a}=J(...r)(n.isSet?c:n.isMap?{key:c[0],value:c[1]}:[...u]);if(m)return a}while(u.length<O||n.isSet||n.isMap);throw new Error(`Hit iterationLimit: ${O}. Use setIterationLimit(Infinity) to disable.`)},J=(...t)=>{let e;return n=>({found:!!t.find(o=>{let i=o(n),{matched:r,value:u}=i||{};return[r,u].every(d)?r(n)&&(e=u(n),!0):i&&(e=i)}),result:e})},K="@@match-iz/rest",at=t=>d(t==null?void 0:t[K]),wt=t=>t[K],G=Symbol("@@match-iz/otherwise"),D=t=>(t==null?void 0:t[G])===!0,Lt=t=>{let e=n=>({matched:()=>!0,value:()=>d(t)?t(n):t});return e[G]=!0,e},I=t=>e=>n=>{let s={haystack:n};return{matched:()=>l(t,n,o=>n=o,s),value:()=>d(e)?y(n)&&U(t)?e(...Ot(n.match(t),s.rest)):e(n,s.rest):e}},Pt=(...t)=>{if(t.length===1){let[e]=t;return I(e)}if(t.length===2){let[e,n]=t;return I(e)(n)}if(t.length>2){let e=t.slice(-1)[0],n=t.slice(0,-1);return I(Ft(n))(e)}throw new Error("Expected at least 1 argument")},Ot=t=>{let{groups:e}=t;return e?[e,t]:[t]},l=(t,e,n,s={haystack:e})=>h(t)?p(t).every(o=>(s.consumedKeys=s.consumedKeys||[],s.consumedKeys.push(o),s.key=o,l(t[o],e==null?void 0:e[o],n,s))):g(t)?g(e)&&t.every((o,i)=>{let r=at(o)?wt(o):o;return s.key=i,l(r,e==null?void 0:e[i],n,s)}):d(t)?t(e,n,s):y(e)&&U(t)?t.test(e):t===e||[t,e].every(Number.isNaN),Rt=(...t)=>(e,n,s)=>t.length===0||(d(t[0])?t[0](e):l(t[0],e,n,s))?(n(e),!0):!1,qt=(...t)=>{let e=t.length===0?()=>!0:t[0],n=o=>(i,r)=>N(i,{[r]:o.haystack[r]}),s=(o,i)=>N(o,{[i]:e});return{[K]:(o,i,r)=>{if(h(r.haystack)){let u=[],c=p(r.haystack).reduce((A,E)=>((r.consumedKeys||[]).includes(E)?u.push(E):A.push(E),A),[]),f=u.reduce(n(r),{}),m=c.reduce(s,{}),a=l(N({},f,m),r.haystack,i);return a&&(r.rest=c.reduce(n(r),{})),a}if(g(r.haystack)){let u=r.haystack.slice(0,r.key),c=r.haystack.slice(r.key).map(()=>e),f=l(u.concat(c),r.haystack,i);return f&&(r.rest=r.haystack.slice(r.key)),f}return!1}}},St=(t,e)=>[t,e].every(g)?t.length===e.length:[t,e].every(h)?p(t).length===p(e).length:!0,vt=t=>(e,n,s)=>St(t,e)&&l(t,e,n,s),zt=t=>M(t,e=>h(e)?vt(e):e),Ct=t=>(e,n,s)=>!l(t,e,n,s),bt=(...t)=>(e,n,s)=>t.flat().some(o=>l(o,e,n,s)),Ft=(...t)=>(e,n,s)=>t.flat().every(o=>l(o,e,n,s)),Ht=t=>T((e,n,s)=>e.every(o=>l(t,o,n,s))),Vt=t=>T((e,n,s)=>e.some(o=>l(t,o,n,s))),$t=(...t)=>W((e,n,s)=>t.length<=e.length&&l(t,e.slice(0,t.length),n,s)),jt=(...t)=>W((e,n,s)=>t.length<=e.length&&l(t,e.slice(e.length-t.length),n,s)),Nt=t=>t!==t||!t&&t!==0&&t!==!1||g(t)&&!t.length||h(t)&&!p(t).length,Bt=t=>!Nt(t),Jt=t=>v(e=>e>t),Ut=t=>v(e=>e<t),Gt=t=>v(e=>e>=t),Qt=t=>v(e=>e<=t),Tt=(t,e)=>v(n=>n>=Math.min(t,e)&&n<=Math.max(t,e)),Xt=t=>Q(e=>e.startsWith(t)),Yt=t=>Q(e=>e.endsWith(t)),Zt=t=>W(e=>e.includes(t)),_t=bt,xt=t=>e=>e===t,kt=(...t)=>e=>h(e)&&(([n,s])=>n.length&&n.every(o=>s.includes(o)))([t.flat(),p(e)]),te=n=>{var s=n,{getValue:t}=s,e=C(s,["getValue"]);return gt(e).reduce((o,[i,r])=>N(o,{[i]:u=>c=>({matched:()=>r(c),value:()=>d(u)?u(t(c)):u})}),{})},ee=t=>!!t,ne=t=>!t,yt=t=>(e,n)=>(e[n]=M(e[n],t),e),Et=t=>e=>M(e,t),M=(t,e)=>e(h(t)?p(t).reduce(yt(e),z({},t)):g(t)?t.map(Et(e)):t),se=t=>new Proxy({},{get:()=>t}),Q=t=>e=>y(e)&&t(e),v=t=>e=>ct(e)&&t(e),T=t=>(e,n,s)=>g(e)&&t(e,n,s),W=t=>(e,n,s)=>(g(e)||y(e))&&t(e,n,s);export{ht as against,Ft as allOf,bt as anyOf,te as cata,zt as deepEq,Bt as defined,Nt as empty,Yt as endsWith,vt as eq,Ht as every,ne as falsy,$t as firstOf,Mt as getIterationLimit,Jt as gt,Gt as gte,kt as hasOwn,Tt as inRange,_t as includedIn,Zt as includes,Kt as instanceOf,g as isArray,Dt as isDate,d as isFunction,ft as isIterable,ct as isNumber,h as isPojo,U as isRegExp,xt as isStrictly,y as isString,jt as lastOf,Ut as lt,Qt as lte,At as match,Ct as not,Lt as otherwise,Rt as pluck,qt as rest,Wt as setIterationLimit,Vt as some,se as spread,Xt as startsWith,ee as truthy,Pt as when};
