/*
 * match-iz
 * v4.0.4
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var M=Object.defineProperty;var v=Object.getOwnPropertySymbols;var L=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var A=(t,n,e)=>n in t?M(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,q=(t,n)=>{for(var e in n||(n={}))L.call(n,e)&&A(t,e,n[e]);if(v)for(var e of v(n))P.call(n,e)&&A(t,e,n[e]);return t};var C=(t,n)=>{var e={};for(var o in t)L.call(t,o)&&n.indexOf(o)<0&&(e[o]=t[o]);if(t!=null&&v)for(var o of v(t))n.indexOf(o)<0&&P.call(t,o)&&(e[o]=t[o]);return e};var K=(t,n)=>{for(var e in n)M(t,e,{get:n[e],enumerable:!0})};var h={};K(h,{instanceOf:()=>g,isArguments:()=>R,isArray:()=>T,isDate:()=>X,isFormData:()=>nt,isFunction:()=>V,isIterable:()=>tt,isMap:()=>y,isNumber:()=>Z,isObject:()=>$,isPojo:()=>k,isRegExp:()=>_,isSet:()=>j,isString:()=>Y});var H=Object.prototype,Q=H.toString,N=t=>n=>typeof n===t,g=t=>n=>n instanceof t,{isArray:T}=Array,R=t=>Q.call(t)==="[object Arguments]",X=t=>g(Date)(t)&&!isNaN(t),V=N("function"),Y=N("string"),Z=t=>t===t&&N("number")(t),$=t=>t!==null&&N("object")(t),_=g(RegExp),j=g(Set),y=g(Map),k=t=>t===null||!$(t)||R(t)?!1:Object.getPrototypeOf(t)===H,tt=t=>t!=null&&[t[Symbol.iterator],t.next].every(V),nt=t=>typeof FormData!="undefined"&&g(FormData)(t);var{isArguments:et,isArray:w,isDate:xt,isFunction:O,isNumber:ot}=h,{isPojo:S,isRegExp:B,isString:x,instanceOf:Et}=h,{isMap:rt,isSet:st,isIterable:it,isFormData:ct}=h,{keys:d,entries:ut,assign:ft}=Object,p=2e4,lt=!0,It=()=>p,Dt=t=>{let n=p;return p=t,()=>p=n};function mt(t,n){for(let e=t.length-1;e>=0;e--)if(n(t[e]))return t[e]}function a(t,n){if(lt&&!D(n)){let e=`Exhausted all patterns without finding a match for input: ${JSON.stringify(t)}. Handle it, or use otherwise() for the fall-through case.`;throw new Error(e)}}function Ft(t){return(...n)=>gt(...n)(t)}var gt=(...t)=>n=>{let[e,o]=et(n)?[{},Array.from(n)]:rt(n)||ct(n)?[{isMap:!0},n.entries()]:st(n)?[{isSet:!0},n.values()]:[{},n];if(!it(o)){let r=o,{found:m,result:f}=z(...t)(r);if(m)return f;let E=mt(t,D);return a(r,E),f}let i=o,[u,l]=t.reduce(([r,m],f)=>D(f)?[f,m]:[r,[...m,f]],[()=>({value:()=>{}}),[]]),c=[];do{let{value:r,done:m}=i.next();if(m)return a(i,u),u().value();c.push(r);let{found:f,result:E}=z(...l)(e.isSet?r:e.isMap?{key:r[0],value:r[1]}:[...c]);if(f)return E}while(c.length<p||e.isSet||e.isMap);throw new Error(`Hit iterationLimit: ${p}. Use setIterationLimit(Infinity) to disable.`)},z=(...t)=>{let n;return e=>({found:!!t.find(i=>{let u=i(e),{matched:l,value:c}=u||{};return[l,c].every(O)?l(e)&&(n=c(e),!0):u&&(n=u)}),result:n})},J=Symbol("@@match-iz/otherwise"),D=t=>(t==null?void 0:t[J])===!0,Wt=t=>{let n=e=>({matched:()=>!0,value:()=>O(t)?t(e):t});return n[J]=!0,n},I=t=>n=>e=>({matched:()=>s(t,e,o=>e=o),value:()=>O(n)?x(e)&&B(t)?n(...pt(e.match(t))):n(e):n}),At=(...t)=>{if(t.length===1){let[n]=t;return I(n)}if(t.length===2){let[n,e]=t;return I(n)(e)}if(t.length>2){let n=t.slice(-1)[0],e=t.slice(0,-1);return I(St(e))(n)}throw new Error("Expected at least 1 argument")},pt=t=>{let{groups:n}=t;return n?[n,t]:[t]},s=(t,n,e)=>S(t)?d(t).every(o=>s(t[o],n==null?void 0:n[o],e)):w(t)?w(n)&&t.length===n.length&&t.every((o,i)=>s(o,n==null?void 0:n[i],e)):O(t)?t(n,e):x(n)&&B(t)?t.test(n):t===n||[t,n].every(Number.isNaN),Mt=(...t)=>(n,e)=>t.length===0||(O(t[0])?t[0](n):s(t[0],n,e))?(e(n),!0):!1,wt=(t,n)=>[t,n].every(S)?d(t).length===d(n).length:!0,dt=t=>(n,e)=>wt(t,n)&&s(t,n,e),Lt=t=>F(t,n=>S(n)?dt(n):n),Pt=t=>(n,e)=>!s(t,n,e),Ot=(...t)=>(n,e)=>t.flat().some(o=>s(o,n,e)),St=(...t)=>(n,e)=>t.flat().every(o=>s(o,n,e)),qt=t=>G(n=>n.every(e=>s(t,e))),Ct=t=>G(n=>n.some(e=>s(t,e))),Ht=(...t)=>W((n,e)=>t.length<=n.length&&s(t,n.slice(0,t.length),e)),Rt=(...t)=>W((n,e)=>t.length<=n.length&&s(t,n.slice(n.length-t.length),e)),ht=t=>t!==t||!t&&t!==0&&t!==!1||w(t)&&!t.length||S(t)&&!d(t).length,Vt=t=>!ht(t),$t=t=>b(n=>n>t),at=t=>b(n=>n<t),zt=t=>b(n=>n>=t),Bt=t=>b(n=>n<=t),Jt=(t,n)=>b(e=>e>=Math.min(t,n)&&e<=Math.max(t,n)),Ut=t=>U(n=>n.startsWith(t)),Gt=t=>U(n=>n.endsWith(t)),Kt=t=>W(n=>n.includes(t)),Qt=Ot,Tt=t=>n=>n===t,Xt=(...t)=>n=>S(n)&&(([e,o])=>e.length&&e.every(i=>o.includes(i)))([t.flat(),d(n)]),Yt=e=>{var o=e,{getValue:t}=o,n=C(o,["getValue"]);return ut(n).reduce((i,[u,l])=>ft(i,{[u]:c=>r=>({matched:()=>l(r),value:()=>O(c)?c(t(r)):c})}),{})},Zt=t=>!!t,_t=t=>!t,bt=t=>(n,e)=>(n[e]=F(n[e],t),n),vt=t=>n=>F(n,t),F=(t,n)=>n(S(t)?d(t).reduce(bt(n),q({},t)):w(t)?t.map(vt(n)):t),jt=t=>new Proxy({},{get:()=>t}),U=t=>n=>x(n)&&t(n),b=t=>n=>ot(n)&&t(n),G=t=>(n,e)=>w(n)&&t(n,e),W=t=>(n,e)=>(w(n)||x(n))&&t(n,e);export{gt as against,St as allOf,Ot as anyOf,Yt as cata,Lt as deepEq,Vt as defined,ht as empty,Gt as endsWith,dt as eq,qt as every,_t as falsy,Ht as firstOf,It as getIterationLimit,$t as gt,zt as gte,Xt as hasOwn,Jt as inRange,Qt as includedIn,Kt as includes,Et as instanceOf,w as isArray,xt as isDate,O as isFunction,it as isIterable,ot as isNumber,S as isPojo,B as isRegExp,Tt as isStrictly,x as isString,Rt as lastOf,at as lt,Bt as lte,Ft as match,Pt as not,Wt as otherwise,Mt as pluck,Dt as setIterationLimit,Ct as some,jt as spread,Ut as startsWith,Zt as truthy,At as when};
