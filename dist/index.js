/*
 * match-iz
 * v4.0.2
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var x=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames,N=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable;var P=(t,n,e)=>n in t?x(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,C=(t,n)=>{for(var e in n||(n={}))D.call(n,e)&&P(t,e,n[e]);if(N)for(var e of N(n))q.call(n,e)&&P(t,e,n[e]);return t};var H=(t,n)=>{var e={};for(var o in t)D.call(t,o)&&n.indexOf(o)<0&&(e[o]=t[o]);if(t!=null&&N)for(var o of N(t))n.indexOf(o)<0&&q.call(t,o)&&(e[o]=t[o]);return e};var R=(t,n)=>{for(var e in n)x(t,e,{get:n[e],enumerable:!0})},tt=(t,n,e,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of k(n))!D.call(t,r)&&r!==e&&x(t,r,{get:()=>n[r],enumerable:!(o=y(n,r))||o.enumerable});return t};var nt=t=>tt(x({},"__esModule",{value:!0}),t);var nn={};R(nn,{against:()=>K,allOf:()=>Y,anyOf:()=>X,cata:()=>Zt,deepEq:()=>Pt,defined:()=>$t,empty:()=>Z,endsWith:()=>Kt,eq:()=>T,every:()=>Ct,falsy:()=>jt,firstOf:()=>Rt,getIterationLimit:()=>xt,gt:()=>at,gte:()=>Bt,hasOwn:()=>Yt,inRange:()=>Ut,includedIn:()=>Tt,includes:()=>Qt,instanceOf:()=>dt,isArray:()=>l,isDate:()=>wt,isFunction:()=>m,isIterable:()=>G,isNumber:()=>U,isPojo:()=>g,isRegExp:()=>A,isStrictly:()=>Xt,isString:()=>b,lastOf:()=>Vt,lt:()=>zt,lte:()=>Jt,match:()=>Dt,not:()=>qt,otherwise:()=>Ft,pluck:()=>Mt,setIterationLimit:()=>Et,some:()=>Ht,spread:()=>tn,startsWith:()=>Gt,truthy:()=>_t,when:()=>Wt});module.exports=nt(nn);var h={};R(h,{instanceOf:()=>d,isArguments:()=>$,isArray:()=>ot,isDate:()=>rt,isFormData:()=>gt,isFunction:()=>a,isIterable:()=>mt,isMap:()=>ft,isNumber:()=>it,isObject:()=>z,isPojo:()=>lt,isRegExp:()=>ct,isSet:()=>ut,isString:()=>st});var V=Object.prototype,et=V.toString,E=t=>n=>typeof n===t,d=t=>n=>n instanceof t,{isArray:ot}=Array,$=t=>et.call(t)==="[object Arguments]",rt=t=>d(Date)(t)&&!isNaN(t),a=E("function"),st=E("string"),it=t=>t===t&&E("number")(t),z=t=>t!==null&&E("object")(t),ct=d(RegExp),ut=d(Set),ft=d(Map),lt=t=>t===null||!z(t)||$(t)?!1:Object.getPrototypeOf(t)===V,mt=t=>t!=null&&[t[Symbol.iterator],t.next].every(a),gt=t=>typeof FormData!="undefined"&&d(FormData)(t);var{isArguments:pt,isArray:l,isDate:wt,isFunction:m,isNumber:U}=h,{isPojo:g,isRegExp:A,isString:b,instanceOf:dt}=h,{isMap:Ot,isSet:St,isIterable:G,isFormData:ht}=h,{keys:S,entries:bt,assign:vt}=Object,O=2e4,Nt=!0,xt=()=>O,Et=t=>{let n=O;return O=t,()=>O=n};function It(t,n){for(let e=t.length-1;e>=0;e--)if(n(t[e]))return t[e]}function B(t,n){if(Nt&&!W(n)){let e=`Exhausted all patterns without finding a match for input: ${JSON.stringify(t)}. Handle it, or use otherwise() for the fall-through case.`;throw new Error(e)}}function Dt(t){return(...n)=>K(...n)(t)}var K=(...t)=>n=>{let[e,o]=pt(n)?[{},Array.from(n)]:Ot(n)||ht(n)?[{isMap:!0},n.entries()]:St(n)?[{isSet:!0},n.values()]:[{},n];if(!G(o)){let s=o,{found:w,result:f}=J(...t)(s);if(w)return f;let I=It(t,W);return B(s,I),f}let r=o,[u,p]=t.reduce(([s,w],f)=>W(f)?[f,w]:[s,[...w,f]],[()=>({value:()=>{}}),[]]),c=[];do{let{value:s,done:w}=r.next();if(w)return B(r,u),u().value();c.push(s);let{found:f,result:I}=J(...p)(e.isSet?s:e.isMap?{key:s[0],value:s[1]}:[...c]);if(f)return I}while(c.length<O||e.isSet||e.isMap);throw new Error(`Hit iterationLimit: ${O}. Use setIterationLimit(Infinity) to disable.`)},J=(...t)=>{let n;return e=>({found:!!t.find(r=>{let u=r(e),{matched:p,value:c}=u||{};return[p,c].every(m)?p(e)&&(n=c(e),!0):u&&(n=u)}),result:n})},Q=Symbol("@@match-iz/otherwise"),W=t=>(t==null?void 0:t[Q])===!0,Ft=t=>{let n=e=>({matched:()=>!0,value:()=>m(t)?t(e):t});return n[Q]=!0,n},F=t=>n=>e=>({matched:()=>i(t,e,o=>e=o),value:()=>m(n)?b(e)&&A(t)?n(...At(e.match(t))):n(e):n}),Wt=(...t)=>{if(t.length===1){let[n]=t;return F(n)}if(t.length===2){let[n,e]=t;return F(n)(e)}if(t.length>2){let n=t.slice(-1)[0],e=t.slice(0,-1);return F(Y(e))(n)}throw new Error("Expected at least 1 argument")},At=t=>{let{groups:n}=t;return n?[n,t]:[t]},i=(t,n,e)=>g(t)?S(t).every(o=>i(t[o],n==null?void 0:n[o],e)):l(t)?l(n)&&t.length===n.length&&t.every((o,r)=>i(o,n==null?void 0:n[r],e)):m(t)?t(n,e):b(n)&&A(t)?t.test(n):t===n||[t,n].every(Number.isNaN),Mt=(...t)=>(n,e)=>t.length===0||(m(t[0])?t[0](n):i(t[0],n,e))?(e(n),!0):!1,Lt=(t,n)=>[t,n].every(g)?S(t).length===S(n).length:!0,T=t=>(n,e)=>Lt(t,n)&&i(t,n,e),Pt=t=>M(t,n=>g(n)?T(n):n),qt=t=>(n,e)=>!i(t,n,e),X=(...t)=>(n,e)=>t.flat().some(o=>i(o,n,e)),Y=(...t)=>(n,e)=>t.flat().every(o=>i(o,n,e)),Ct=t=>j(n=>n.every(e=>i(t,e))),Ht=t=>j(n=>n.some(e=>i(t,e))),Rt=(...t)=>L((n,e)=>t.length<=n.length&&i(t,n.slice(0,t.length),e)),Vt=(...t)=>L((n,e)=>t.length<=n.length&&i(t,n.slice(n.length-t.length),e)),Z=t=>t!==t||!t&&t!==0&&t!==!1||l(t)&&!t.length||g(t)&&!S(t).length,$t=t=>!Z(t),at=t=>v(n=>n>t),zt=t=>v(n=>n<t),Bt=t=>v(n=>n>=t),Jt=t=>v(n=>n<=t),Ut=(t,n)=>v(e=>e>=Math.min(t,n)&&e<=Math.max(t,n)),Gt=t=>_(n=>n.startsWith(t)),Kt=t=>_(n=>n.endsWith(t)),Qt=t=>L(n=>n.includes(t)),Tt=X,Xt=t=>n=>n===t,Yt=(...t)=>n=>g(n)&&(([e,o])=>e.length&&e.every(r=>o.includes(r)))([t.flat(),S(n)]),Zt=e=>{var o=e,{getValue:t}=o,n=H(o,["getValue"]);return bt(n).reduce((r,[u,p])=>vt(r,{[u]:c=>s=>({matched:()=>p(s),value:()=>m(c)?c(t(s)):c})}),{})},_t=t=>!!t,jt=t=>!t,yt=t=>(n,e)=>(n[e]=M(n[e],t),n),kt=t=>n=>M(n,t),M=(t,n)=>n(g(t)?S(t).reduce(yt(n),C({},t)):l(t)?t.map(kt(n)):t),tn=t=>new Proxy({},{get:()=>t}),_=t=>n=>b(n)&&t(n),v=t=>n=>U(n)&&t(n),j=t=>(n,e)=>l(n)&&t(n,e),L=t=>(n,e)=>(l(n)||b(n))&&t(n,e);0&&(module.exports={against,allOf,anyOf,cata,deepEq,defined,empty,endsWith,eq,every,falsy,firstOf,getIterationLimit,gt,gte,hasOwn,inRange,includedIn,includes,instanceOf,isArray,isDate,isFunction,isIterable,isNumber,isPojo,isRegExp,isStrictly,isString,lastOf,lt,lte,match,not,otherwise,pluck,setIterationLimit,some,spread,startsWith,truthy,when});
